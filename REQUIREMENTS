Requirements for the implementation:
* Hereditage.
  - At least one abstract class, that must be implemented in derived classes.
* Parametric polimorfism: templates.
* Functions as first order elements and High-Order functions.
  + A particle could return a function that says is gravitational field without the next particle effect on it yet.
* Lists that modify high-order functions and elements.
* Lambda functions.
  + The main calculations of forces can be done by lambda functions.
* Currying.
  + We could create a general log message function and 'curry' it to generate errors, warnings, infos...
* Pattern matching functions (on their definitions).
  + Could be used in the place of delegates. In that case, there could be a compiling flag that selects which one will be used on the simulation.
* Recursion as iteration.
* Delegates.
  + Delegates can be used upon particle force evaluation. If a particle has electricfield(), call it. Otherwhise, don't.

SOLVED:
* Classes: all over the place.
* Attribute protection: all over the place.
* Default constructors: Storage, Point
* Destructors: Window
* Namespaces: all the classes are inside namespaces.
* Hierarchy:
  - Three levels: the electric particle is the third level.
  - Inclusion polimorphism: the Storage class has vector<Point>, and it receives Particles, Electrics...
* Overload Polimorphism: In Particle.
