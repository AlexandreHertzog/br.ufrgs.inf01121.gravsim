Requirements for the implementation:
* Lists that modify high-order functions and elements.
* Pattern matching functions (on their definitions).
  + Could be used in the place of delegates. In that case, there could be a compiling flag that selects which one will be used on the simulation.
* Recursion as iteration.
* Delegates.
  + Delegates can be used upon particle force evaluation. If a particle has electricfield(), call it. Otherwhise, don't.

SOLVED:
* Classes: all over the place.
* Attribute protection: all over the place.
* Default constructors: Storage, Point
* Destructors: Window
* Namespaces: all the classes are inside namespaces.
* Hierarchy:
  - Three levels: the electric particle is the third level.
  - Inclusion polimorphism: the Storage class has vector<Point>, and it receives Particles, Electrics...
* Overload Polimorphism: In Particle.
* Parametric Polimorphism: in util.hh
* Functions as first order elements and High-Order functions: in util.hh
* Lambda functions: used to initialize the std::function in particle.hh
* Currying: used in Particle::GetField()
* Abstract class: GSObject and Particle are possible abstract classes, because they have pure virtual methods.

